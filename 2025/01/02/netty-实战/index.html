<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>netty 入门实战 | XYJ</title><meta name="author" content="XYJ"><meta name="copyright" content="XYJ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本篇文章为《跟着闪电侠学 netty》的学习记录。 Netty 是什么传统 IO&#x2F;阻塞 IO先来看看传统的 IO 编程。 实现一下一个场景，客户端每个两秒发送一个带有时间戳的“hello,world”给服务端，服务端接收并打印。 服务端首先要创建一个 ServerSocket 来监听 8000 端口，然后创建一个新线程，线程不断调用ServerSocket 中的 accept 方法获取新">
<meta property="og:type" content="article">
<meta property="og:title" content="netty 入门实战">
<meta property="og:url" content="https://troublingrainblue.github.io/2025/01/02/netty-%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="XYJ">
<meta property="og:description" content="本篇文章为《跟着闪电侠学 netty》的学习记录。 Netty 是什么传统 IO&#x2F;阻塞 IO先来看看传统的 IO 编程。 实现一下一个场景，客户端每个两秒发送一个带有时间戳的“hello,world”给服务端，服务端接收并打印。 服务端首先要创建一个 ServerSocket 来监听 8000 端口，然后创建一个新线程，线程不断调用ServerSocket 中的 accept 方法获取新">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://troublingrainblue.github.io/img/51160511_p0_master1200.jpg">
<meta property="article:published_time" content="2025-01-02T05:57:25.000Z">
<meta property="article:modified_time" content="2025-01-30T11:24:45.320Z">
<meta property="article:author" content="XYJ">
<meta property="article:tag" content="netty">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://troublingrainblue.github.io/img/51160511_p0_master1200.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://troublingrainblue.github.io/2025/01/02/netty-%E5%AE%9E%E6%88%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'netty 入门实战',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-30 19:24:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清單</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/51160511_p0_master1200.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="XYJ"><span class="site-name">XYJ</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清單</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">netty 入门实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-02T05:57:25.000Z" title="发表于 2025-01-02 13:57:25">2025-01-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-30T11:24:45.320Z" title="更新于 2025-01-30 19:24:45">2025-01-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="netty 入门实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本篇文章为《跟着闪电侠学 netty》的学习记录。</p>
<h1 id="Netty-是什么"><a href="#Netty-是什么" class="headerlink" title="Netty 是什么"></a>Netty 是什么</h1><h2 id="传统-IO-阻塞-IO"><a href="#传统-IO-阻塞-IO" class="headerlink" title="传统 IO&#x2F;阻塞 IO"></a>传统 IO&#x2F;阻塞 IO</h2><p>先来看看传统的 IO 编程。</p>
<p>实现一下一个场景，客户端每个两秒发送一个带有时间戳的“hello,world”给服务端，服务端接收并打印。</p>
<p>服务端首先要创建一个 ServerSocket 来监听 8000 端口，然后创建一个新线程，线程不断调用<br>ServerSocket 中的 accept 方法获取新连接，获得新连接后再为每个连接创建一个线程，这个线程负责读数据。</p>
<p>服务端代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收新连接线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 1 阻塞方法获取新连接</span></span><br><span class="line">                   <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 2 为每个新连接创建一个新线程，负责读取数据</span></span><br><span class="line">                   <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="type">int</span> len;</span><br><span class="line">                           <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                           <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">                           <span class="keyword">while</span>((len = inputStream.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                               System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, len));</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;).start();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端的实现相对简单，只要连接上服务端的端口重复发送数据即可。</p>
<p>客户端代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8000</span>);</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        socket.getOutputStream().write((<span class="keyword">new</span> <span class="title class_">Date</span>()+<span class="string">&quot;:hello world&quot;</span>).getBytes());</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个连接创建成功后都需要一个线程来维护，一旦客户端数量多起来，就会导致线程资源受限，同一时刻有大量线程阻塞，造成严重资源浪费。其次，线程的频繁切换也会带来极大的开销，同时，数据读写也是以字节流为单位。</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>为了解决传统 IO 的问题，JDK 在 1.4 版本之后提出了 NIO。</p>
<p>在 NIO 模型中，新来的连接不再需要创建一个新线程，而是可以把这个连接直接绑定到某个固定线程，然后这个连接的所有读写都由这个线程来完成。NIO 模型中的 Selector 组件在这样过程起着重要作用。一个连接来了之后，不会创建一个 while 死循环去监听时候有数据可读，而是直接把这条连接注册到 Selector 上。然后，通过检查 Selector，就可以批量监测出有数据可读写的连接，进而读取数据。</p>
<p>这样，在 NIO 模型中的线程数量也大大降低，减少了线程切换的开销。同时，NIO 的读写面向的是 Buffer 而不是字节流，可以读取里面任何字节数据，不需要自己缓存数据，只需移动指针即可。</p>
<p>在 NIO 模型中通常会有两个线程，每个线程都绑定一个 Selector。一个负责轮询是否有新连接，另一个负责轮询连接是否有数据可读。服务端在监测到新连接之后，不在创建一个新线程，而是直接将连接绑定到负责轮询数据的 Selector 上。</p>
<p>原生 NIO 的代码编写太过复杂，jdk 也没实现比较适合 NIO 的一个线程模型，甚至拆包也要自己编写，还有空轮询导致 cpu 占有率飙升的 bug，故不太建议使用原生 NIO 进行网络编程。</p>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>Netty 就是封装了 JDK 的 NIO，让使用 NIO 编程更为方便。Netty 底层的 IO 模型可以随意切换，只需要小小的改动一下参数，Netty 就可以从 NIO 编程 IO。Netty 自带拆包粘包、异常检测等机制，使得开发者可以将更多精力放在业务逻辑上。Netty 也解决了 JDK 很多包括空轮询在内的 Bug。Netty 底层对线程、Selector 做了很多细小的优化、，精心设计的 Reactor 线程模型可以做到非常高效的并发处理，还自带各种协议栈，通用协议几乎不需要亲自动手。</p>
<p>使用 Netty 需要先导入 jar 包。这里使用 Maven 导入。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.101.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Netty 实现上述 Server：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        bootstrap.group(boss, worker)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>())</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                        System.out.println(s);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).bind(<span class="number">8000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Netty 客户端实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        bootstrap.group(group).channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8000</span>).channel();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>()+<span class="string">&quot;:hello world&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="服务端启动流程"><a href="#服务端启动流程" class="headerlink" title="服务端启动流程"></a>服务端启动流程</h1><h2 id="服务端启动最小化代码"><a href="#服务端启动最小化代码" class="headerlink" title="服务端启动最小化代码"></a>服务端启动最小化代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        bootstrap.group(boss, worker)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>())</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                        System.out.println(s);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).bind(<span class="number">8000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先创建了两个 NioEventLoopGroup，这两个对象可以看作传统 IO 编程模型的两大线程组，boss 表示监听端口，接收新连接；worker 表示处理每一组连接的数据读写的线程组。其次创建了一个引导类 ServerBootstrap，引导服务端的启动工作。通过.group(boss, worker)给引导类配置两大线程组，这个引导类的模型就定型了。再通过.channel(NioServerSocketChannel.class)指定服务端的 IO 模型为 NIO。接着调用 childHandler()方法，给引导类创建一个 ChannelInitializer 里面有一个泛型参数 NioSocketChannel，这个就对应 BIO 中的 Socket。配置好了这三样就完成了一个最小的 Netty 服务端，最后通过.bind()绑定一个本地端口启动服务端。</p>
<h2 id="自动绑定递增端口"><a href="#自动绑定递增端口" class="headerlink" title="自动绑定递增端口"></a>自动绑定递增端口</h2><p>若当前端口不可用，为了正常启动需要找到一个可用的端口，如端口 8000 不可用，就继续尝试 8001，8002，直到绑定成功。bootstrap.bind(8000)是一个异步方法，调用之后是立即返回的，它的返回值是一个 ChannelFuture。可以通过给这个 ChannelFuture 添加一个监听器 GenericFutureLitstener 去监听端口是否绑定成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="keyword">final</span> ServerBootstrap bootstrap, <span class="keyword">final</span> <span class="type">int</span> port)</span> &#123;</span><br><span class="line">    bootstrap.bind(port).addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="built_in">super</span> Void&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;? <span class="built_in">super</span> Void&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span>(future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;端口&quot;</span>+port+<span class="string">&quot;绑定成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;端口&quot;</span>+port+<span class="string">&quot;绑定失败&quot;</span>);</span><br><span class="line">                bind(bootstrap, port + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务端启动的其他方法"><a href="#服务端启动的其他方法" class="headerlink" title="服务端启动的其他方法"></a>服务端启动的其他方法</h2><h3 id="handler"><a href="#handler" class="headerlink" title="handler()"></a>handler()</h3><p>childHandler()方法用于指定处理新连接数据的读写逻辑;handler()方法用于指定在服务端启动过程中的一些逻辑，一般不使用这个方法。</p>
<h3 id="attr"><a href="#attr" class="headerlink" title="attr()"></a>attr()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.arrt(AttributeKey.newInstance(<span class="string">&quot;serverName&quot;</span>), <span class="string">&quot;NettyServer&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>attr()方法可以给服务端 Channel，也就是 NioServerSocketChannel 指定一些自定义属性，然后通过 channel.attr()取出这个属性，一般不使用这个方法。上述代码的意思就是指定 channel 的 serverName 属性，属性值为 NettyServer。实际上就是维护了一个 Map。</p>
<h3 id="childAttr"><a href="#childAttr" class="headerlink" title="childAttr()"></a>childAttr()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.childAttr(AttributeKey.newInstance(<span class="string">&quot;clientKey&quot;</span>), <span class="string">&quot;NettyClient&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>childAttr()方法可以给每一个连接自定义属性，可以通过 channel.attr()方法取出。</p>
<h3 id="option"><a href="#option" class="headerlink" title="option()"></a>option()</h3><p>option()方法可以给服务端 channel 设置一些 TCP 参数，最常用的就是 so_backlog。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<p>这个设置表示用于临时存放已完成三次握手的请求队列的最大长度，如果连接建立频繁可以适当调大这个参数。</p>
<h3 id="childOption"><a href="#childOption" class="headerlink" title="childOption()"></a>childOption()</h3><p>可以给每一个连接设置一些 TCP 参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">    .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>ChannelOption.SO_KEEPALIVE 表示是否开启 TCP 底层心跳机制。</li>
<li>ChannelOption.TCP_NODELAY 表示是否开启 Nagle 算法。通常如果要求高实时性就设置为 true 表示关闭；如果要减少发送次数、减少网络交互就设置为 false，表示开启。</li>
</ul>
<h1 id="客户端启动流程"><a href="#客户端启动流程" class="headerlink" title="客户端启动流程"></a>客户端启动流程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="comment">// 指定线程模型</span></span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                <span class="comment">// 指定IO类型为NIO</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">// IO逻辑处理</span></span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        bootstrap.connect(<span class="string">&quot;juejin.com&quot;</span>, <span class="number">80</span>).addListener(future -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span>(future.isSuccess()) &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;连接失败&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="失败重连"><a href="#失败重连" class="headerlink" title="失败重连"></a>失败重连</h2><p>在网络情况较差的情况下，客户端第一次连接可能会失败，这时可能会需要尝试重连</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(Bootstrap bootstrap, String host, <span class="type">int</span> port, <span class="type">int</span> retry)</span> &#123;</span><br><span class="line">        bootstrap.connect(host, port).addListener(future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(retry == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接失败&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 假设最多重连10次</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">order</span> <span class="operator">=</span> <span class="number">16</span> - retry + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 重试的时间间隔</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">delay</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; order, <span class="number">10</span> ;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:连接失败，第&quot;</span> + order + <span class="string">&quot;次重连&quot;</span>);</span><br><span class="line">                bootstrap.config().group().schedule(()-&gt;connect(bootstrap, host, port, retry - <span class="number">1</span>),</span><br><span class="line">                        delay, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实现定时任务调用的是 bootstrap.config().group().schedule()，其中 bootstrap.config()返回的是 BootstrapConfig，它是对 Bootstrap 配置参数的抽象，bootstrap.config().group()返回的就是前面给客户端配置的线程 group，通过调用 group 的 schedule 方法即可实现定时任务。</p>
<h2 id="客户端启动的其他放啊"><a href="#客户端启动的其他放啊" class="headerlink" title="客户端启动的其他放啊"></a>客户端启动的其他放啊</h2><h3 id="attr-1"><a href="#attr-1" class="headerlink" title="attr()"></a>attr()</h3><p>给客户端 channel 自定义绑定属性，然后通过 channel.attr() 取出。</p>
<h3 id="option-1"><a href="#option-1" class="headerlink" title="option()"></a>option()</h3><p>设置一些 TCP 参数。</p>
<h1 id="客户端与服务端双向通信"><a href="#客户端与服务端双向通信" class="headerlink" title="客户端与服务端双向通信"></a>客户端与服务端双向通信</h1><h2 id="客户端发送数据到服务端"><a href="#客户端发送数据到服务端" class="headerlink" title="客户端发送数据到服务端"></a>客户端发送数据到服务端</h2><p>客户端的数据读写逻辑是通过 bootstrap.handler()指定的。</p>
<p>添加一个逻辑处理器，负责向服务端发送数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FirstClientHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>socketChannel.pipeline()返回的是和这条连接相关的逻辑处理链，采用了责任链模式。</li>
<li>调用 addLast()方法添加一个逻辑处理器，这个处理器负责在连接建立后向服务端发送数据。</li>
</ul>
<p>处理器实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:客户端写出数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> getByteBuf(ctx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        ctx.channel().writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ByteBuf <span class="title function_">getByteBuf</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取二进制抽象bytebuf</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备数据</span></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="string">&quot;Hello,nya!&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据填充进 bytebuf</span></span><br><span class="line">        byteBuf.writeBytes(data);</span><br><span class="line">        <span class="keyword">return</span> byteBuf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>处理器通过继承 ChannelInboundHandlerAdapter，覆盖 channelActive()方法，这个方法会在客户端连接建立成功之后被调用。</li>
<li>连接建立成功之后需要通过 Bytebuf 发送数据。</li>
<li>通过 ctx.alloc 获得一个 Bytebuf 内存管理器，然后把数据的二进制字节填入 Bytebuf，再通过 ctx.channel().writeAndFlush(byteBuf)把数据写道服务端。</li>
</ul>
<h2 id="服务端读取客户端数据"><a href="#服务端读取客户端数据" class="headerlink" title="服务端读取客户端数据"></a>服务端读取客户端数据</h2><p>服务端的数据读写逻辑是在 ServerBootstrap 的.childHandler()方法指定的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.group(boss, worker)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FirstServerHandler</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>处理器实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:服务端收到的数据---&gt;&quot;</span>+byteBuf.toString(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与客户端不同的是，channelRead()方法再接收到客户端发来的数据之后被回调。</p>
<p>至于为什么要强转 msg，之后会进行详细分析。</p>
<h2 id="服务端返回数据到客户端"><a href="#服务端返回数据到客户端" class="headerlink" title="服务端返回数据到客户端"></a>服务端返回数据到客户端</h2><p>一样是通过 ctx.channel().writeAndFlush(byteBuf)的方式来进行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 省略接收逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回数据到客户端</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:服务端写出数据&quot;</span>);</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">out</span> <span class="operator">=</span> getBytebuf(ctx);</span><br><span class="line">        ctx.channel().writeAndFlush(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ByteBuf <span class="title function_">getBytebuf</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="string">&quot;你好，欢迎来到Ave Mujica的世界&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        byteBuf.writeBytes(data);</span><br><span class="line">        <span class="keyword">return</span> byteBuf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端也需要重写 channelRead()来接收服务端返回的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 发送逻辑省略</span></span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:客户端收到的响应结果---&gt;&quot;</span>+byteBuf.toString(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据载体-Bytebuf"><a href="#数据载体-Bytebuf" class="headerlink" title="数据载体 Bytebuf"></a>数据载体 Bytebuf</h1><h2 id="Bytebuf-的结构"><a href="#Bytebuf-的结构" class="headerlink" title="Bytebuf 的结构"></a>Bytebuf 的结构</h2><p>Bytebuf 是一个字节容器，容器里面的数据分为三部分，第一部分是已经丢弃的字节，第二部分是可读字节，第三部分是可写字节。这三个部分通过读写指针划分出来，还有一个 capacity 变量表示 Bytebuf 的总容量。每从 Byetbuf 中读取一字节，读指针（readerIndex）自增 1，Bytebuf 里总共有 writerIndex - readerIndex 字节可读。写数据则是从 writerIndex 所指位置开始写，每写一字节，写指针（writerIndex）自增 1，知道 writerIndex &#x3D; capacity。</p>
<h2 id="容量-API"><a href="#容量-API" class="headerlink" title="容量 API"></a>容量 API</h2><ul>
<li>capacity()：表示 Bytebuf 底层占用了多少字节的内存。</li>
<li>maxCapacity()：表示 Bytebuf 底层最多能占用多少字节。向 Bytebuf 写数据是，若发现 capacity 不足可以进行扩容，只知道 capacity 达到 maxCapacity，超过这个数就抛出异常。</li>
<li>readableBytes()与 isReadable()：前者表示 Bytebuf 当前可读的字节数，即 writerIndex - readerIndex，若为 0 则不可读，isReadable()返回 false。</li>
<li>writableBytes()、isWritable()、maxWritableByte()：和读函数类似，writableBytes()返回的是 capacity - writerIndex，若为 0 则不可写，isWritable 返回 false，这是 Netty 会对 Bytebuf 进行扩容，直至内存大小为 maxCapacity，maxWritableByte 就是计算最多还能写多少数据。</li>
</ul>
<h2 id="读写指针-API"><a href="#读写指针-API" class="headerlink" title="读写指针 API"></a>读写指针 API</h2><ul>
<li>readerIndex()和 readerIndex(int)：前者获得读指针，后者设置读指针。</li>
<li>writeIndex()和 writeIndex(int)：前者获得写指针，后者设置写指针。</li>
<li>markReaderIndex()和 resetReaderIndex()：前者表示把当前的读指针保存起来，后者表示把读指针恢复到之前保存的值。</li>
<li>markWriteIndex()和 resetWriteIndex()：与第三条类似，是对写指针的操作。</li>
</ul>
<p>如果可以，尽量使用后两种 API，这样不需要定义变量。</p>
<h2 id="读写-API"><a href="#读写-API" class="headerlink" title="读写 API"></a>读写 API</h2><h3 id="writeBytes-byte-src-和-buffer-readBytes-byte-dst"><a href="#writeBytes-byte-src-和-buffer-readBytes-byte-dst" class="headerlink" title="writeBytes(byte[] src)和 buffer.readBytes(byte[] dst)"></a>writeBytes(byte[] src)和 buffer.readBytes(byte[] dst)</h3><p>writeBytes()表示把字节数组 src 里的说有数据全部写入 Bytebuf，而 readBytes 表示把 Bytebuf 里的全部数据读到字节数组 dst 中。</p>
<h3 id="writeByte-byte-b-和-buffer-readByte"><a href="#writeByte-byte-b-和-buffer-readByte" class="headerlink" title="writeByte(byte b)和 buffer.readByte();"></a>writeByte(byte b)和 buffer.readByte();</h3><p>writeByte()表示向 Bytebuf 里写入一字节，readByte()表示读一字节。对于不同的数据类型都有类似的 API，如 writeInt()、writeLong()、writeBoolean()等。</p>
<h3 id="release-和-retain"><a href="#release-和-retain" class="headerlink" title="release()和 retain()"></a>release()和 retain()</h3><p>由于 Netty 使用了堆外内存，而堆外内存是不被 JVM 直接管理的。也就是说，申请到的内存无法被垃圾回收器直接回收，所以需要我们手动回收。这有点类似于 C 语言里，申请到的内存必须手工释放，否则会造成内存泄漏。</p>
<p>Netty 的 ByteBuf 是通过引用计数的方式管理的，如果一个 ByteBuf 没有地方被引用到，则需要回收底层内存。在默认情况下，当创建完一个 ByteBuf 时，它的引用为 1，然后每次调用 retain()方法，它的引用就加一，release()方法的原理是将引用计数减一，减完之后如果发现引用计数为 0，则直接回收 ByteBuf 底层的内存。</p>
<h3 id="slice-、duplicate-、copy"><a href="#slice-、duplicate-、copy" class="headerlink" title="slice()、duplicate()、copy()"></a>slice()、duplicate()、copy()</h3><ol>
<li>slice()方法从原始 ByteBuf 中截取一段，这段数据是从 readerIndex 到 writeIndex 的，同时，返回的新的 ByteBuf 的最大容量 maxCapacity 为原始 ByteBuf 的 readableBytes()。</li>
<li>duplicate()方法把整个 ByteBuf 都截取出来，包括所有的数据、指针信息。</li>
<li>slice()方法与 duplicate()方法的相同点是：底层内存及引用计数与原始 ByteBuf 共享，也就是说，经过 slice()方法或者 duplicate()方法返回的 ByteBuf 调用 write 系列方法都会影响到原始 ByteBuf，但是它们都维持着与原始 ByteBuf 相同的内存引用计数和不同的读写指针。</li>
<li>slice()方法与 duplicate()方法的不同点就是：slice()方法只截取从 readerIndex 到 writerIndex 之间的数据，它返回的 ByteBuf 的最大容量被限制到原始 ByteBuf 的 readableBytes()，而 duplicate()方法是把整个 ByteBuf 都与原始 ByteBuf 共享。</li>
<li>slice()方法与 duplicate()方法不会复制数据，它们只是通过改变读写指针来改变读写的行为，而最后一个方法 copy()会直接从原始 ByteBuf 中复制所有的信息，包括读写指针及底层对应的数据，因此，往 copy()方法返回的 ByteBuf 中写数据不会影响原始 ByteBuf。</li>
<li>slice()方法和 duplicate()方法不会改变 ByteBuf 的引用计数，所以原始 ByteBuf 调用 release()方法之后发现引用计数为零，就开始释放内存，调用这两个方法返回的 ByteBuf 也会被释放。这时候如果再对它们进行读写，就会报错。因此，我们可以通过调用一次 retain()方法来增加引用，表示它们对应的底层内存多了一次引用，引用计数为 2。在释放内存的时候，需要调用两次 release()方法，将引用计数降到零，才会释放内存。</li>
<li>这三个方法均维护着自己的读写指针，与原始 ByteBuf 的读写指针无关，相互之间不受影响。</li>
</ol>
<p>在使用 slice()、duplicate()的时候要理清内存共享、引用计数共享、读写指针不共享。</p>
<p>展示两个常见错误</p>
<p>（1）多次释放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Buffer</span> <span class="variable">buffer</span> <span class="operator">=</span> xxx;</span><br><span class="line">doWith(buffer); <span class="comment">// 也可以是Netty的回调方法，这里只是作为例子展示</span></span><br><span class="line"><span class="comment">// 一次释放</span></span><br><span class="line">buffer.release();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWith</span><span class="params">(Bytebuf buffer)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有增加引用计数</span></span><br><span class="line">    <span class="type">Buffer</span> <span class="variable">slice</span> <span class="operator">=</span> buffer.slice();</span><br><span class="line">    foo(slice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">foo</span><span class="params">(Bytebuf buffer)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理数据...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重复释放</span></span><br><span class="line">    buffer.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）不释放造成内存泄漏</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Buffer</span> <span class="variable">buffer</span> <span class="operator">=</span> xxx;</span><br><span class="line">doWith(buffer); <span class="comment">// 也可以是Netty的回调方法，这里只是作为例子展示</span></span><br><span class="line"><span class="comment">// 引用计数为2却只释放了一次</span></span><br><span class="line">buffer.release();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWith</span><span class="params">(Bytebuf buffer)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数+1</span></span><br><span class="line">    <span class="type">Buffer</span> <span class="variable">slice</span> <span class="operator">=</span> buffer.reatainedSlice();</span><br><span class="line">    foo(slice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">foo</span><span class="params">(Bytebuf buffer)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理数据...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Demo-演示"><a href="#Demo-演示" class="headerlink" title="Demo 演示"></a>Demo 演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BytebufTest</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buffer</span>  <span class="operator">=</span>  ByteBufAllocator.DEFAULT.buffer(<span class="number">9</span>,  <span class="number">100</span>);</span><br><span class="line">        print(<span class="string">&quot;allocate  ByteBuf(9,  100)&quot;</span>,  buffer);</span><br><span class="line">        <span class="comment">//  write方法改变写指针，写完之后写指针未到capacity的时候，buffer仍然可写</span></span><br><span class="line">        buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[] &#123;<span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>&#125;);</span><br><span class="line">        print(<span class="string">&quot;writeBytes(1,2,3,4)&quot;</span>,  buffer);</span><br><span class="line">        <span class="comment">//  write方法改变写指针，写完之后写指针未到capacity的时候，buffer仍然可写，写完int类型之后，写指针增加4</span></span><br><span class="line">        buffer.writeInt(<span class="number">12</span>);</span><br><span class="line">        print(<span class="string">&quot;writeInt(12)&quot;</span>,  buffer);</span><br><span class="line">        <span class="comment">//  write方法改变写指针，写完之后写指针等于capacity的时候，buffer不可写</span></span><br><span class="line">        buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">5</span>&#125;);</span><br><span class="line">        print(<span class="string">&quot;writeBytes(5)&quot;</span>,  buffer);</span><br><span class="line">        <span class="comment">//  write方法改变写指针，写的时候发现buffer不可写则开始扩容，扩容之后capacity随即改变</span></span><br><span class="line">        buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>&#125;);</span><br><span class="line">        print(<span class="string">&quot;writeBytes(6)&quot;</span>,  buffer);</span><br><span class="line">        <span class="comment">//  get方法不改变读写指针</span></span><br><span class="line">        System.out.println(<span class="string">&quot;getByte(3)  return：&quot;</span>  +  buffer.getByte(<span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;getShort(3)  return：&quot;</span>  +  buffer.getShort(<span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;getInt(3)  return：&quot;</span>  +  buffer.getInt(<span class="number">3</span>));</span><br><span class="line">        print(<span class="string">&quot;getByte()&quot;</span>,  buffer);</span><br><span class="line">        <span class="comment">//  set方法不改变读写指针</span></span><br><span class="line">        buffer.setByte(buffer.readableBytes()  +  <span class="number">1</span>,  <span class="number">0</span>);</span><br><span class="line">        print(<span class="string">&quot;setByte()&quot;</span>,  buffer);</span><br><span class="line">        <span class="comment">//  read方法改变读指针</span></span><br><span class="line">        <span class="type">byte</span>[] dst  = <span class="keyword">new</span> <span class="title class_">byte</span> [buffer.readableBytes()];</span><br><span class="line">        buffer.readBytes(dst);</span><br><span class="line">        print(<span class="string">&quot;readBytes(&quot;</span>  +  dst.length  +  <span class="string">&quot;)&quot;</span>,  buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">print</span><span class="params">(String  action,  ByteBuf  buffer)</span>  &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after  ===========&quot;</span>  +  action  +  <span class="string">&quot;============&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;capacity()：&quot;</span>  +  buffer.capacity());</span><br><span class="line">        System.out.println(<span class="string">&quot;maxCapacity()：&quot;</span>  +  buffer.maxCapacity());</span><br><span class="line">        System.out.println(<span class="string">&quot;readerIndex()：&quot;</span>  +  buffer.readerIndex());</span><br><span class="line">        System.out.println(<span class="string">&quot;readableBytes()：&quot;</span>  +  buffer.readableBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;isReadable()：&quot;</span>  +  buffer.isReadable());</span><br><span class="line">        System.out.println(<span class="string">&quot;writerIndex()：&quot;</span>  +  buffer.writerIndex());</span><br><span class="line">        System.out.println(<span class="string">&quot;writableBytes()：&quot;</span>  +  buffer.writableBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;isWritable()：&quot;</span>  +  buffer.isWritable());</span><br><span class="line">        System.out.println(<span class="string">&quot;maxWritableBytes()：&quot;</span>  +  buffer.maxWritableBytes());</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="通信协议编解码"><a href="#通信协议编解码" class="headerlink" title="通信协议编解码"></a>通信协议编解码</h1><p>无论使用 Netty 还是原始的 Socket 编程，基于 TCP 通信的数据包格式都是二进制字节流，协议就是客户端与服务端实现商量好多每个数据包中，每一段二进制字节分别代表什么含意。</p>
<h2 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h2><ol>
<li>魔数，4 字节。为了避免所有数据包都按照约定的协议进行处理导致其他协议失效。</li>
<li>版本号，1 字节。通常为预留字段，应对版本升级。</li>
<li>序列化算法，1 字节。</li>
<li>指令，1 字节。表示数据是做什么的。</li>
<li>数据长度，4 字节。</li>
<li>后续字节为数据部分。</li>
</ol>
<h2 id="协议实现"><a href="#协议实现" class="headerlink" title="协议实现"></a>协议实现</h2><p>协议中任何一种报文都有版本号和获取指令的方法，提取抽象成一个公共类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Packet</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Byte</span> <span class="variable">version</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Byte <span class="title function_">getCommand</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以登录请求为例，定义登录请求的数据包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="type">Byte</span> <span class="variable">LOGIN_REQUEST</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginRequest</span> <span class="keyword">extends</span> <span class="title class_">Packet</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Byte <span class="title function_">getCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Command.LOGIN_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JSON 序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Serializer</span> <span class="variable">DEFAULT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONSerializer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">byte</span> <span class="title function_">getSerializerAlgorithm</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java 对象转二进制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">byte</span>[] serialize(Object obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二进制转 java 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] data)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SerializerAlgorithm</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JSON 序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Byte</span> <span class="variable">JSON</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON 序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JSONSerializer</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span> <span class="title function_">getSerializerAlgorithm</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SerializerAlgorithm.JSON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONBytes(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(data, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编解码在 PacketCodeC.java 中实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PacketCodeC</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAGIC_NUMBER</span> <span class="operator">=</span> <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">public</span> ByteBuf <span class="title function_">encode</span><span class="params">(Packet packet)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Bytebuf</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.ioBuffer();</span><br><span class="line">        <span class="comment">// 序列化对象</span></span><br><span class="line">        <span class="type">byte</span>[] data = Serializer.DEFAULT.serialize(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// header</span></span><br><span class="line">        byteBuf.writeInt(MAGIC_NUMBER);</span><br><span class="line">        byteBuf.writeByte(packet.getVersion());</span><br><span class="line">        byteBuf.writeByte(Serializer.DEFAULT.getSerializerAlgorithm());</span><br><span class="line">        byteBuf.writeByte(packet.getCommand());</span><br><span class="line">        byteBuf.writeInt(data.length);</span><br><span class="line">        <span class="comment">// body</span></span><br><span class="line">        byteBuf.writeBytes(data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> byteBuf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码</span></span><br><span class="line">    <span class="keyword">public</span> Packet <span class="title function_">decode</span><span class="params">(ByteBuf byteBuf)</span> &#123;</span><br><span class="line">        <span class="comment">// 按理应该检查魔数，这里业务单一就做简单的跳过处理</span></span><br><span class="line">        byteBuf.skipBytes(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过版本号</span></span><br><span class="line">        byteBuf.skipBytes(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化方式</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerAlgorithm</span> <span class="operator">=</span> byteBuf.readByte();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指令</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">command</span> <span class="operator">=</span> byteBuf.readByte();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据包长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> byteBuf.readInt();</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        byteBuf.readBytes(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Packet</span>&gt; requestType = getRequestType(command);</span><br><span class="line">        <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> getSerializer(serializerAlgorithm);</span><br><span class="line">        <span class="keyword">if</span>(requestType != <span class="literal">null</span> &amp;&amp; serializer != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> serializer.deserialize(requestType, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Serializer <span class="title function_">getSerializer</span><span class="params">(<span class="type">byte</span> serializerAlgorithm)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(serializerAlgorithm == SerializerAlgorithm.JSON) <span class="keyword">return</span> Serializer.DEFAULT;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Packet</span>&gt; getRequestType(<span class="type">byte</span> command) &#123;</span><br><span class="line">        <span class="keyword">if</span>(command == <span class="number">1</span>) <span class="keyword">return</span> LoginRequest.class;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="客户端登录"><a href="#客户端登录" class="headerlink" title="客户端登录"></a>客户端登录</h1><p>客户端会先构建一个登录请求对象，然后通过编码把请求对象编码为 ByteBuf，写到服务端。服务端接收到 ByteBuf 后，先对收到的 ByteBuf 解码为登录响应请求，进行校验。通过校验之后，构造一个响应对象，编码返回客户端。客户端解码，根据响应对象判断是否登录成功。</p>
<p>将客户端和服务端的 Handler 更换成 ClientHandler 和 ServerHandler，后续处理逻辑在这个两个类中实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先客户端创建请求并发送。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:客户端开始登录&quot;</span>);</span><br><span class="line">    <span class="type">LoginRequest</span> <span class="variable">loginRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequest</span>();</span><br><span class="line">    loginRequest.setUserId(UUID.randomUUID().toString());</span><br><span class="line">    loginRequest.setUsername(<span class="string">&quot;soyo&quot;</span>);</span><br><span class="line">    loginRequest.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> PacketCodeC.getINSTANCE().encode(ctx.alloc(), loginRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送</span></span><br><span class="line">    ctx.writeAndFlush(byteBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端接收，解码并处理请求，生成响应返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码</span></span><br><span class="line">    <span class="type">Packet</span> <span class="variable">packet</span> <span class="operator">=</span> PacketCodeC.getINSTANCE().decode(byteBuf);</span><br><span class="line">    <span class="type">LoginResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginResponse</span>();</span><br><span class="line">    <span class="keyword">if</span>(packet <span class="keyword">instanceof</span> LoginRequest) &#123;</span><br><span class="line">        <span class="type">LoginRequest</span> <span class="variable">request</span> <span class="operator">=</span> (LoginRequest) packet;</span><br><span class="line">        request.setVersion(request.getVersion());</span><br><span class="line">        <span class="keyword">if</span>(vaild(request)) &#123;</span><br><span class="line">            <span class="comment">// 校验成功</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;校验成功&quot;</span>);</span><br><span class="line">            response.setSuccess(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 校验失败</span></span><br><span class="line">            System.out.println(<span class="string">&quot;校验失败&quot;</span>);</span><br><span class="line">            response.setSuccess(<span class="literal">false</span>);</span><br><span class="line">            response.setMsg(<span class="string">&quot;账号密码校验失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送响应</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">responseBuf</span> <span class="operator">=</span> PacketCodeC.getINSTANCE().encode(ctx.alloc(), response);</span><br><span class="line">        ctx.writeAndFlush(responseBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设用户是 saki</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">vaild</span><span class="params">(LoginRequest loginRequest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> loginRequest.getUsername().equals(<span class="string">&quot;saki&quot;</span>) &amp;&amp; loginRequest.getPassword().equals(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端处理响应</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">    <span class="type">Packet</span> <span class="variable">packet</span> <span class="operator">=</span> PacketCodeC.getINSTANCE().decode(byteBuf);</span><br><span class="line">    <span class="keyword">if</span>(packet <span class="keyword">instanceof</span> LoginResponse) &#123;</span><br><span class="line">        <span class="type">LoginResponse</span> <span class="variable">response</span> <span class="operator">=</span> (LoginResponse) packet;</span><br><span class="line">        <span class="keyword">if</span>(response.getSuccess()) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: 客户端登录成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: 客户端登录失败--&gt;&quot;</span> + response.getMsg());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="客户端与服务端收发消息"><a href="#客户端与服务端收发消息" class="headerlink" title="客户端与服务端收发消息"></a>客户端与服务端收发消息</h1><h2 id="定义消息对象"><a href="#定义消息对象" class="headerlink" title="定义消息对象"></a>定义消息对象</h2><p>客户端发送给服务端的消息为定义为 MessageRequest。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageRequest</span> <span class="keyword">extends</span> <span class="title class_">Packet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Byte <span class="title function_">getCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Command.MESSAGE_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置指令 MESSAGE_REQUEST &#x3D; 3。</p>
<p>服务端发送给客户端的消息为 MessageResponse。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageResponse</span> <span class="keyword">extends</span> <span class="title class_">Packet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Byte <span class="title function_">getCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Command.MESSAGE_RESPONSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断是否登录成功"><a href="#判断是否登录成功" class="headerlink" title="判断是否登录成功"></a>判断是否登录成功</h2><p>客户端在发送消息之前需要登录，登录成功才能发消息。可以通过给 Channel 绑定属性来保存客户端的登录状态。</p>
<p>定义登录成功的标志位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Attributes</span> &#123;</span><br><span class="line">    AttributeKey&lt;Boolean&gt; LOGIN = AttributeKey.newInstance(<span class="string">&quot;login&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 NettyClient 连接成功后启动应用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(Bootstrap bootstrap, String host, <span class="type">int</span> port, <span class="type">int</span> retry)</span> &#123;</span><br><span class="line">    bootstrap.connect(host, port).addListener(future -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(future.isSuccess()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 连接成功之后启动控制台线程</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ((ChannelFuture)future).channel();</span><br><span class="line">            starConsoleThread(channel);</span><br><span class="line">        &#125; <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">starConsoleThread</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(LoginUtil.hasLogin(channel)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入消息发送至服务端&quot;</span>);</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                <span class="comment">// 构造消息请求</span></span><br><span class="line">                <span class="type">MessageRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageRequest</span>();</span><br><span class="line">                request.setMsg(line);</span><br><span class="line">                <span class="comment">// 发送</span></span><br><span class="line">                <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> PacketCodeC.getINSTANCE().encode(channel.alloc(), request);</span><br><span class="line">                channel.writeAndFlush(byteBuf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务端收发消息"><a href="#服务端收发消息" class="headerlink" title="服务端收发消息"></a>服务端收发消息</h2><p>用 if 分支区分 packet 是 Login 相关还是 Message 相关</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解码</span></span><br><span class="line">        <span class="type">Packet</span> <span class="variable">packet</span> <span class="operator">=</span> PacketCodeC.getINSTANCE().decode(byteBuf);</span><br><span class="line">        <span class="keyword">if</span>(packet <span class="keyword">instanceof</span> LoginRequest) &#123;</span><br><span class="line">            <span class="comment">// 登录处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(packet <span class="keyword">instanceof</span> MessageRequest) &#123;</span><br><span class="line">            <span class="comment">// 消息处理</span></span><br><span class="line">            <span class="type">MessageRequest</span> <span class="variable">request</span> <span class="operator">=</span> (MessageRequest) packet;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: 收到客户端消息--&gt;&quot;</span>+ request.getMsg());</span><br><span class="line">            <span class="type">MessageResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageResponse</span>();</span><br><span class="line">            response.setMsg(<span class="string">&quot;服务端回复:&quot;</span>+request.getMsg());</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">responseBuf</span> <span class="operator">=</span> PacketCodeC.getINSTANCE().encode(ctx.alloc(), response);</span><br><span class="line">            ctx.writeAndFlush(responseBuf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端接收消息"><a href="#客户端接收消息" class="headerlink" title="客户端接收消息"></a>客户端接收消息</h2><p>和服务端类似读处理方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line"></span><br><span class="line">        <span class="type">Packet</span> <span class="variable">packet</span> <span class="operator">=</span> PacketCodeC.getINSTANCE().decode(byteBuf);</span><br><span class="line">        <span class="keyword">if</span>(packet <span class="keyword">instanceof</span> LoginResponse) &#123;</span><br><span class="line">            <span class="comment">// 处理登录响应</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(packet <span class="keyword">instanceof</span> MessageResponse) &#123;</span><br><span class="line">            <span class="comment">// 处理消息响应</span></span><br><span class="line">            <span class="type">MessageResponse</span> <span class="variable">response</span> <span class="operator">=</span> (MessageResponse) packet;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: 收到服务端消息--&gt;&quot;</span> + response.getMsg());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Pipline-和-ChannelHandler"><a href="#Pipline-和-ChannelHandler" class="headerlink" title="Pipline 和 ChannelHandler"></a>Pipline 和 ChannelHandler</h1><p>随着指令的增多，对指令处理的 if-else 不可避免的会泛滥，同时一端的所有逻辑都写在一个类里，最后也会变得十分臃肿。此外，每次发送协议报文时都需要手动调用编码器。Netty 中的 Pipeline 和 ChannelHandler 就是解决这个问题的。它通过责任链模式组织代码逻辑，并且支持逻辑的动态添加和删除，Netty 能够支持各类协议的扩展，如 HTTP、WebSocket 等，靠的就是 Pipline 和 ChannelHandler。</p>
<h2 id="Pipline-和-ChannelHandler-的构成"><a href="#Pipline-和-ChannelHandler-的构成" class="headerlink" title="Pipline 和 ChannelHandler 的构成"></a>Pipline 和 ChannelHandler 的构成</h2><p><img src="https://cdn.acwing.com/media/article/image/2025/01/05/104918_a6424818cb-QQ20250105-092951.png" alt="Pipline-and-Channel"></p>
<p>在 Netty 中，一个连接对应着一个 Channel，这个 Channel 的所有处理逻辑都在一个叫作 ChannelPipeline 的对象里，ChannelPipeline 是双向链表结构，它和 Channel 之间是一对一的关系。ChannelPipeline 里的每个节点都是一个 ChannelHandlerContext 对象，这个对象能够获得和 Channel 相关的所有上下文信息。这个对象同时包含一个重要的对象，那就是逻辑处理器 ChannelHandler，每个 ChannelHandler 都处理一块独立的逻辑。</p>
<h2 id="ChannelHandler-的分类"><a href="#ChannelHandler-的分类" class="headerlink" title="ChannelHandler 的分类"></a>ChannelHandler 的分类</h2><p><strong>ChannelInboundHandler</strong></p>
<p>就像名字描述的一样，负责处理读数据的逻辑。在一端读到一段数据，首先要解析这段数据，然后堆这段数据做一系列逻辑处理，最终把响应写道另一端。在组装响应前的所有处理逻辑都可以放置在一系列 ChannelInboundHandler 中处理，其中最重要的方法就是 channelRead()。</p>
<p><strong>ChannelOutboundHandler</strong></p>
<p>它是定义一端在组装完响应之后把数据写到另一端的逻辑，核心方法是 write()。</p>
<p><strong>ChannelInboundHandler 的事件传播</strong></p>
<p>InboundHandler 的执行顺序和通过 addLast()方法添加的顺序保持一致。</p>
<p><strong>ChannelOutboundHandler 的事件传播</strong></p>
<p>InboundHandler 的执行顺序和通过 addLast()方法添加的顺序保持相反。</p>
<h1 id="构建服务端和客户端的-Pipeline"><a href="#构建服务端和客户端的-Pipeline" class="headerlink" title="构建服务端和客户端的 Pipeline"></a>构建服务端和客户端的 Pipeline</h1><p><strong>ByteToMessageDecoder</strong></p>
<p>通常情况下，无论在客户端还是在服务端，当我们收到数据后，首先要做的就是把二进制数据转换到 Java 对象，所以 Netty 很贴心地提供了一个父类，来专门做这个事情。我们看一下如何使用这个类来实现服务端的解码。当继承了 ByteToMessageDecoder 这个类之后，只需要实现 decode()方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PacketDecoder</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageDecoder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        list.add(PacketCodeC.getINSTANCE().decode(byteBuf));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三个参数是 List 类型，我们通过向这个 List 里面添加解码后的结果对象，就可以自动实现结果向下一个 Handler 传递，这样就实现了解码的逻辑 Handler。另外，值得注意的是，对于 Netty 里的 ByteBuf，我们使用 4.1.6.Final 版本，默认情况下用的是堆外内存。在 ByteBuf 一章中提到，堆外内存需要我们自行释放，在解码的例子中，其实我们已经漏掉了这个操作，这一点是非常致命的。随着程序运行得越来越久，内存泄漏的问题就慢慢暴露出来了，而这里我们使用 ByteToMessageDecoder，Netty 会自动进行内存的释放，我们不用操心太多的内存管理方面的逻辑。</p>
<p><strong>MessageToByteEncoder</strong></p>
<p>解码提供了 ByteToMessageDecoder 类，那么编码自然也少不了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PacketEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToByteEncoder</span>&lt;Packet&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Packet packet, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        PacketCodeC.getINSTANCE().encode(byteBuf, packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型参数 Packet 表示这个类的作用是实现 Packet 类型对象到二进制数据的转换。这里我们只需要实现 encode()方法。在这个方法里，第二个参数是 Java 对象，而第三个参数是 ByteBuf 对象，我们要做的事情就是，把 Java 对象的字段写到 ByteBuf 对象，而不再需要自行去分配 ByteBuf 对象。因此，大家注意到，PacketCodeC 的 encode()方法的定义也改了，下面是更改前后的对比。</p>
<p>PacketCodeC.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ByteBuf <span class="title function_">encode</span><span class="params">(ByteBuf byteBuf, Packet packet)</span> &#123;</span><br><span class="line">    <span class="comment">// 序列化对象</span></span><br><span class="line">    <span class="type">byte</span>[] data = Serializer.DEFAULT.serialize(packet);</span><br><span class="line">    <span class="comment">// header</span></span><br><span class="line">    byteBuf.writeInt(MAGIC_NUMBER);</span><br><span class="line">    byteBuf.writeByte(packet.getVersion());</span><br><span class="line">    byteBuf.writeByte(Serializer.DEFAULT.getSerializerAlgorithm());</span><br><span class="line">    byteBuf.writeByte(packet.getCommand());</span><br><span class="line">    byteBuf.writeInt(data.length);</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">    byteBuf.writeBytes(data);</span><br><span class="line">    <span class="keyword">return</span> byteBuf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SimpleChannelInboundHandler</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line"></span><br><span class="line">    <span class="type">Packet</span> <span class="variable">packet</span> <span class="operator">=</span> PacketCodeC.getINSTANCE().decode(byteBuf);</span><br><span class="line">    <span class="keyword">if</span>(packet <span class="keyword">instanceof</span> LoginResponse) &#123;</span><br><span class="line">        <span class="comment">// 处理登录响应</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(packet <span class="keyword">instanceof</span> MessageResponse) &#123;</span><br><span class="line">        <span class="comment">// 处理消息响应</span></span><br><span class="line">        <span class="type">MessageResponse</span> <span class="variable">response</span> <span class="operator">=</span> (MessageResponse) packet;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: 收到服务端消息--&gt;&quot;</span> + response.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面我们使用 if-else 来对指令进行处理，当指令变得越来越多，代码会显得十分臃肿，if-else 最终泛滥，我们可以通过向 pipeline 中添加多个 Handler 来解决这个问题。基于这个 if-else 的逻辑，Netty 抽象出了一个<strong>SimpleChannelInboundHandler</strong>对象，自动实现了类型判断和对象传递。</p>
<p>接下来使用<strong>SimpleChannelInboundHandler</strong>优化之前的逻辑</p>
<p>LoginResponseHandler.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginResponseHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;LoginResponse&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:客户端开始登录&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">LoginRequest</span> <span class="variable">loginRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequest</span>();</span><br><span class="line">        loginRequest.setUserId(UUID.randomUUID().toString());</span><br><span class="line">        loginRequest.setUsername(<span class="string">&quot;saki&quot;</span>);</span><br><span class="line">        loginRequest.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ctx.channel().writeAndFlush(loginRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(response.getSuccess()) &#123;</span><br><span class="line">            LoginUtil.markAsLogin(ctx.channel());</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: 客户端登录成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: 客户端登录失败--&gt;&quot;</span> + response.getMsg());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过泛型参数，在 channelRead0()方法里不需要强转，也不需要判断时候由改 Handler 进行处理。LoginRequestHandler 的编写也是类似的。</p>
<p>LoginRequestHandler.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginRequestHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;LoginRequest&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginRequest loginRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.channel().writeAndFlush(login(loginRequest));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LoginResponse <span class="title function_">login</span><span class="params">(LoginRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 登录处理</span></span><br><span class="line">        <span class="type">LoginResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginResponse</span>();</span><br><span class="line">        <span class="keyword">if</span>(vaild(request)) &#123;</span><br><span class="line">            <span class="comment">// 校验成功</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;校验成功&quot;</span>);</span><br><span class="line">            response.setSuccess(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 校验失败</span></span><br><span class="line">            System.out.println(<span class="string">&quot;校验失败&quot;</span>);</span><br><span class="line">            response.setSuccess(<span class="literal">false</span>);</span><br><span class="line">            response.setMsg(<span class="string">&quot;账号密码校验失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设全部登录成功</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">vaild</span><span class="params">(LoginRequest loginRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loginRequest.getUsername().equals(<span class="string">&quot;saki&quot;</span>) &amp;&amp; loginRequest.getPassword().equals(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 Message 的处理也是一样</p>
<p>MessageRequestHandler.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageRequestHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;MessageRequest&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 消息处理</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: 收到客户端消息--&gt;&quot;</span>+ request.getMsg());</span><br><span class="line">        ctx.channel().writeAndFlush(receive(request));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageResponse <span class="title function_">receive</span><span class="params">(MessageRequest request)</span> &#123;</span><br><span class="line">        <span class="type">MessageResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageResponse</span>();</span><br><span class="line">        response.setMsg(<span class="string">&quot;服务端回复:&quot;</span>+request.getMsg());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MessageResponseHandler.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageResponseHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;MessageResponse&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, MessageResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: 收到服务端消息--&gt;&quot;</span> + response.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="拆包-粘包"><a href="#拆包-粘包" class="headerlink" title="拆包&#x2F;粘包"></a>拆包&#x2F;粘包</h1><p>由于读者模拟了很久也没有出现粘包的现象，这里只能引用书上的图了。</p>
<p><img src="https://cdn.acwing.com/media/article/image/2025/01/28/104918_27514050dd-QQ20250128-231116.png" alt="QQ20250128-231116.png"></p>
<p>可以看到有三种情况。</p>
<ol>
<li>字符串正常输出。</li>
<li>多个字符串被粘在一起。</li>
<li>一个字符串被拆开，形成一个破碎的包。</li>
</ol>
<p>尽管我们在应用层面使用了 Netty，但是操作系统只认 TCP 协议；尽管我们的应用层按照 ByteBuf 为单位来发送数据，但是到了底层操作系统，仍然是按照字节流发送数据的，因此，数据到了服务端，也按照字节流的方式读入，然后到了 Netty 应用层面，重新拼装成 ByteBuf。这里的 ByteBuf 与客户端按照顺序发送的 ByteBuf 可能是不对等的。因此，我们需要在客户端根据自定义协议来组装应用层的数据包，然后在服务端根据应用层的协议来组装数据包，这个过程通常在服务端被称为拆包，而在客户端被称为粘包。</p>
<p>拆包和粘包是相对的，一端粘了包，另外一端就需要将粘过的包拆开。举个例子，发送端将三个数据包粘成两个 TCP 数据包发送到接收端，接收端就需要根据应用协议将两个数据包重新拆分成三个数据包</p>
<p>解决拆包就是检查数据是否足够构成一个数据包。如果有多余就保存多余的，尝试和下一次读到的数据尝试拼接。如果不足也是保留，尝试和下一次读到的数据尝试拼接。</p>
<h2 id="Netty-自带的拆包器"><a href="#Netty-自带的拆包器" class="headerlink" title="Netty 自带的拆包器"></a>Netty 自带的拆包器</h2><p><strong>FixedLengthFrameDecoder</strong></p>
<p>这是固定长度的拆包器。如果应用层协议非常简单，每个数据包的长度都是固定的，传入长度参数，添加到 pipeline 中，Netty 会自动把一个个固定长度数据包传递到下一个 channelHandler 中。</p>
<p><strong>LineBasedFrameDecoder</strong></p>
<p>发送端发送数据包的时候，每个数据包之间以换行符作为分隔，接收端通过 LineBasedFrameDecoder 将粘过的 ByteBuf 拆分成一个个完整的应用层数据包。</p>
<p><strong>DelimiterBasedFrameDecoder</strong></p>
<p>可以自定义分隔符的行拆包器。</p>
<p><strong>LengthFieldBasedFrameDecoder</strong></p>
<p>这是是最通用的一种拆包器，只要你的自定义协议中包含长度域字段，均可以使用这个拆包器来实现应用层拆包。</p>
<h2 id="LengthFieldBasedFrameDecode-的使用"><a href="#LengthFieldBasedFrameDecode-的使用" class="headerlink" title="LengthFieldBasedFrameDecode 的使用"></a>LengthFieldBasedFrameDecode 的使用</h2><p>回顾协议设计：</p>
<ol>
<li>魔数，4 字节。为了避免所有数据包都按照约定的协议进行处理导致其他协议失效。</li>
<li>版本号，1 字节。通常为预留字段，应对版本升级。</li>
<li>序列化算法，1 字节。</li>
<li>指令，1 字节。表示数据是做什么的。</li>
<li>数据长度，4 字节。</li>
<li>后续字节为数据部分。</li>
</ol>
<p>数据长度开始于第七个字节，总共占中了四个字节。</p>
<p>故传入的 LengthFieldBasedFrameDecode 应该定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecode</span>(Interger.MAX_VALUE, <span class="number">7</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>第一个参数指的是数据包的最大长度，第二个参数指的是长度域的偏移量，第三个参数指的是长度域的长度。</p>
<h2 id="拒绝非本协议连接"><a href="#拒绝非本协议连接" class="headerlink" title="拒绝非本协议连接"></a>拒绝非本协议连接</h2><p>前面提到过，魔数就可以是否是改协议的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Spliter</span> <span class="keyword">extends</span> <span class="title class_">LengthFieldBasedFrameDecoder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LENGTH_FIELD_OFFSET</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LENGTH_FIELD_LENGTH</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Spliter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Integer.MAX_VALUE, LENGTH_FIELD_OFFSET, LENGTH_FIELD_LENGTH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(in.getInt(in.readerIndex()) != PacketCodeC.getMagicNumber()) &#123;</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.decode(ctx, in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ChannelHandler-生命周期"><a href="#ChannelHandler-生命周期" class="headerlink" title="ChannelHandler 生命周期"></a>ChannelHandler 生命周期</h1><p>自定义一个处理器，添加到 pipeline 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifeCyCleTestHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;逻辑处理器被添加: handlerAdded()&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.handlerAdded(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channel 绑定到线程(NioEventLoop): channelRegistered()&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.channelRegistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channel 准备就绪: channelActive()&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channel 有数据可读: channelRead()&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channel 某次数据读完: channelReadComplete()&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.channelReadComplete(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channel 被关闭: channelInactive()&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.channelInactive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channel 取消线程(NioEventLoop)的绑定: channelUnregistered()&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.channelUnregistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;逻辑处理器被移除: handlerRemoved()&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.handlerRemoved(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察服务端控制台</p>
<p><strong>运行客户端</strong></p>
<p><img src="https://cdn.acwing.com/media/article/image/2025/01/29/104918_d61a6016de-QQ20250129-164527.png" alt="QQ20250129-164527.png"></p>
<p><strong>关闭客户端</strong></p>
<p><img src="https://cdn.acwing.com/media/article/image/2025/01/29/104918_052c7794de-QQ20250129-165702.png" alt="QQ20250129-165702.png"></p>
<ol>
<li>handlerAdded()：指当检测到新连接之后，调用 ch.pipeline().addLast(new LifeCyCleTestHandler());之后的回调，表示在当前 Channel 中，已经成功添加了一个 Handler 处理器。</li>
<li>channelRegistered()：这个回调方法表示当前 Channel 的所有逻辑处理已经和某个 NIO 线程建立了绑定关系，接收新的连接，然后创建一个线程来处理这个连接的读写，只不过在 Netty 里使用了线程池的方式，只需要从线程池里去抓一个线程绑定在这个 Channel 上即可。这里的 NIO 线程通常指 NioEventLoop。</li>
<li>channelActive()：当 Channel 的所有业务逻辑链准备完毕（即 Channel 的 Pipeline 中已经添加完所有的 Handler），以及绑定好一个 NIO 线程之后，这个连接才真正被激活，接下来就会回调到此方法。</li>
<li>channelRead()：客户端向服务端发送数据，每次都会回调此方法，表示有数据可读。</li>
<li>channelReadComplete()：服务端每读完一次完整的数据，都回调该方法，表示数据读取完毕。</li>
<li>channelInactive()：表面上这个连接已经被关闭了，这个连接在 TCP 层面已经不再是 ESTABLISH 状态了。</li>
<li>channelUnregistered()：既然连接已经被关闭，那么与这个连接绑定的线程就不需要对这个连接负责了。这个回调表明与这个连接对应的 NIO 线程移除了对这个连接的处理。</li>
<li>handlerRemoved()：我们给这个连接添加的所有业务逻辑处理器都被移除。</li>
</ol>
<h1 id="使用-ChannelHandler-的热插拔实现客户端身份校验"><a href="#使用-ChannelHandler-的热插拔实现客户端身份校验" class="headerlink" title="使用 ChannelHandler 的热插拔实现客户端身份校验"></a>使用 ChannelHandler 的热插拔实现客户端身份校验</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    nioSocketChannel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">Spliter</span>())</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">PacketDecoder</span>())</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">LoginRequestHandler</span>())</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">AuthHandler</span>())</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">MessageRequestHandler</span>())</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">PacketEncoder</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Server 中添加一个 AuthHandler，后续的指令都会先经过 AuthHandler 的一层过滤。</p>
<p><strong>AuthHandler.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(!LoginUtil.hasLogin(ctx.channel())) &#123;</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已经登录成功，不需要在进行校验</span></span><br><span class="line">            ctx.pipeline().remove(<span class="built_in">this</span>);</span><br><span class="line">            <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(LoginUtil.hasLogin(ctx.channel())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登录验证通过，无需再次验证，AuthHandler被移除&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无登录验证，强制关闭连接&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 channelRead()方法里，在决定是否把读到的数据传递到后续指令处理器之前，首先会判断是否登录成功。如果未登录，则直接强制关闭连接，否则，就把读到的数据向下传递，传递给后续指令处理器。在客户端校验通过之后，我们不再需要 AuthHandler 这段逻辑，通过 ctx.pipeline().remove()方法删除即可。</p>
<h1 id="客户端互聊"><a href="#客户端互聊" class="headerlink" title="客户端互聊"></a>客户端互聊</h1><h2 id="一对一单聊原理"><a href="#一对一单聊原理" class="headerlink" title="一对一单聊原理"></a>一对一单聊原理</h2><ol>
<li>A 要和 B 聊天，首先 A 和 B 需要与服务器建立连接，然后进行一次登录流程，服务端保存用户标识和 TCP 连接的映射关系。</li>
<li>A 发消息给 B，首先需要将带有 B 标识的消息数据包发送到服务器，然后服务器从消息数据包中获得 B 的标识，找到对应 B 的连接，将消息发送给 B。</li>
</ol>
<h2 id="用户状态与-Channel-绑定"><a href="#用户状态与-Channel-绑定" class="headerlink" title="用户状态与 Channel 绑定"></a>用户状态与 Channel 绑定</h2><p>参考保存登录状态的经验可以通过给 Channel 添加属性来绑定。</p>
<p><strong>LoginRequestHandler.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext  ctx,  LoginRequest request)</span> &#123;</span><br><span class="line">    <span class="type">LoginResponse</span> <span class="variable">loginResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginResponse</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    loginResponse.setUserId(userId);</span><br><span class="line">    SessionUtil.bindSession(<span class="keyword">new</span> <span class="title class_">Session</span>(userId, request.getUsername()), ctx.channel());</span><br><span class="line">    loginResponse.setSuccess(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//  登录响应</span></span><br><span class="line">    ctx.channel().writeAndFlush(loginResponse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  用户断线之后取消绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext  ctx)</span> &#123;</span><br><span class="line">    SessionUtil.unBindSession(ctx.channel());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>登录成功后服务端会创建 Session 对象对当前会话信息进行保存。</p>
<p><strong>Session.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Session</span> &#123;</span><br><span class="line">    <span class="comment">// 用户唯一标识</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Session</span><span class="params">(String userId, String userName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userId = userId;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SessionUtil.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionUtil</span> &#123;</span><br><span class="line">    <span class="comment">// 用户与Channel的映射</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Channel&gt; userIdChannelMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bindSession</span><span class="params">(Session session, Channel channel)</span> &#123;</span><br><span class="line">        userIdChannelMap.put(session.getUserId(), channel);</span><br><span class="line">        channel.attr(Attributes.SESSION).set(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unBindSession</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasLogin(channel)) &#123;</span><br><span class="line">            userIdChannelMap.remove(getSession(channel).getUserId());</span><br><span class="line">            channel.attr(Attributes.SESSION).set(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasLogin</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> channel.hasAttr(Attributes.SESSION);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title function_">getSession</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> channel.attr(Attributes.SESSION).get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title function_">getChannel</span><span class="params">(String  userId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userIdChannelMap.get(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 Map 维护 userId 到 channel 的映射，可以通过 userId 获得对应 Channel。同时通过给 Channel 添加 Session 属性可以获得 Channel 属于哪个用户。</p>
<h2 id="服务端接收消息并转发"><a href="#服务端接收消息并转发" class="headerlink" title="服务端接收消息并转发"></a>服务端接收消息并转发</h2><p>要发送给确定的人，消息的数据格式需要增加一个 toUserId。</p>
<p><strong>MessageRequest.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageRequest</span> <span class="keyword">extends</span> <span class="title class_">Packet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String toUserId;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Byte <span class="title function_">getCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Command.MESSAGE_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageRequest</span><span class="params">(String toUserId, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.toUserId = toUserId;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端根据发送方的 channel 获取 session，得知消息发送方的信息，和消息一起进行转发。转发的目标 channel 通过 SessionUtil 维护的 userId 与 channel 的 map 获得。</p>
<p><strong>MessageRequestHandler.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageRequestHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;MessageRequest&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 消息处理</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: 收到客户端消息--&gt;&quot;</span>+ request.getMsg());</span><br><span class="line">        <span class="comment">// 获取发送方消息的会话信息</span></span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> SessionUtil.getSession(ctx.channel());</span><br><span class="line">        <span class="type">MessageResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageResponse</span>();</span><br><span class="line">        response.setFromUserId(session.getUserId());</span><br><span class="line">        response.setFromUserName(session.getUserName());</span><br><span class="line">        response.setMsg(request.getMsg());</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">toUserChannel</span> <span class="operator">=</span> SessionUtil.getChannel(request.getToUserId());</span><br><span class="line">        <span class="keyword">if</span>(toUserChannel != <span class="literal">null</span> &amp;&amp; SessionUtil.hasLogin(toUserChannel)) &#123;</span><br><span class="line">            toUserChannel.writeAndFlush(response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[ &quot;</span> + request.getToUserId() + <span class="string">&quot; ] 不在线，发送失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端接收消息-1"><a href="#客户端接收消息-1" class="headerlink" title="客户端接收消息"></a>客户端接收消息</h2><p>这里就比较简单了，接收消息并打印即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageResponseHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;MessageResponse&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, MessageResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fromUserId</span> <span class="operator">=</span> response.getFromUserId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">fromUserName</span> <span class="operator">=</span> response.getFromUserName();</span><br><span class="line">        System.out.println(fromUserId + <span class="string">&quot;:&quot;</span> + fromUserName + <span class="string">&quot;-&gt;&quot;</span> + response.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果</strong></p>
<p><img src="https://cdn.acwing.com/media/article/image/2025/01/30/104918_1d42df38de-6dede8bdb4bf66822717209349a6a6df.png" alt="6dede8bdb4bf66822717209349a6a6df.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://TroublingRainBlue.github.io">XYJ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://troublingrainblue.github.io/2025/01/02/netty-%E5%AE%9E%E6%88%98/">https://troublingrainblue.github.io/2025/01/02/netty-%E5%AE%9E%E6%88%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://TroublingRainBlue.github.io" target="_blank">XYJ</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/netty/">netty</a></div><div class="post_share"><div class="social-share" data-image="/img/51160511_p0_master1200.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/01/23/zookeeper/" title="zookeeper"><img class="cover" src="/img/51160511_p0_master1200.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">zookeeper</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/08/%E6%89%8B%E6%92%B8RPC/" title="手撸RPC框架"><img class="cover" src="/img/XYJ1169080555732136.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">手撸RPC框架</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">XYJ</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/TroublingRainBlue"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/TroublingRainBlue" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">加油</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Netty-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.</span> <span class="toc-text">Netty 是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F-IO-%E9%98%BB%E5%A1%9E-IO"><span class="toc-number">1.1.</span> <span class="toc-text">传统 IO&#x2F;阻塞 IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO"><span class="toc-number">1.2.</span> <span class="toc-text">NIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty"><span class="toc-number">1.3.</span> <span class="toc-text">Netty</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">服务端启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%9C%80%E5%B0%8F%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.</span> <span class="toc-text">服务端启动最小化代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%BB%91%E5%AE%9A%E9%80%92%E5%A2%9E%E7%AB%AF%E5%8F%A3"><span class="toc-number">2.2.</span> <span class="toc-text">自动绑定递增端口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">服务端启动的其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#handler"><span class="toc-number">2.3.1.</span> <span class="toc-text">handler()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#attr"><span class="toc-number">2.3.2.</span> <span class="toc-text">attr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#childAttr"><span class="toc-number">2.3.3.</span> <span class="toc-text">childAttr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#option"><span class="toc-number">2.3.4.</span> <span class="toc-text">option()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#childOption"><span class="toc-number">2.3.5.</span> <span class="toc-text">childOption()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">客户端启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%BF%9E"><span class="toc-number">3.1.</span> <span class="toc-text">失败重连</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%AF%E5%8A%A8%E7%9A%84%E5%85%B6%E4%BB%96%E6%94%BE%E5%95%8A"><span class="toc-number">3.2.</span> <span class="toc-text">客户端启动的其他放啊</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#attr-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">attr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#option-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">option()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1"><span class="toc-number">4.</span> <span class="toc-text">客户端与服务端双向通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">4.1.</span> <span class="toc-text">客户端发送数据到服务端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%BB%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%B0%E6%8D%AE"><span class="toc-number">4.2.</span> <span class="toc-text">服务端读取客户端数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E5%88%B0%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">4.3.</span> <span class="toc-text">服务端返回数据到客户端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BD%BD%E4%BD%93-Bytebuf"><span class="toc-number">5.</span> <span class="toc-text">数据载体 Bytebuf</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Bytebuf-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">Bytebuf 的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E9%87%8F-API"><span class="toc-number">5.2.</span> <span class="toc-text">容量 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%8C%87%E9%92%88-API"><span class="toc-number">5.3.</span> <span class="toc-text">读写指针 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99-API"><span class="toc-number">5.4.</span> <span class="toc-text">读写 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#writeBytes-byte-src-%E5%92%8C-buffer-readBytes-byte-dst"><span class="toc-number">5.4.1.</span> <span class="toc-text">writeBytes(byte[] src)和 buffer.readBytes(byte[] dst)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#writeByte-byte-b-%E5%92%8C-buffer-readByte"><span class="toc-number">5.4.2.</span> <span class="toc-text">writeByte(byte b)和 buffer.readByte();</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#release-%E5%92%8C-retain"><span class="toc-number">5.4.3.</span> <span class="toc-text">release()和 retain()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slice-%E3%80%81duplicate-%E3%80%81copy"><span class="toc-number">5.4.4.</span> <span class="toc-text">slice()、duplicate()、copy()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Demo-%E6%BC%94%E7%A4%BA"><span class="toc-number">5.5.</span> <span class="toc-text">Demo 演示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%BC%96%E8%A7%A3%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">通信协议编解码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.1.</span> <span class="toc-text">协议设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.</span> <span class="toc-text">协议实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%99%BB%E5%BD%95"><span class="toc-number">7.</span> <span class="toc-text">客户端登录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF"><span class="toc-number">8.</span> <span class="toc-text">客户端与服务端收发消息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.1.</span> <span class="toc-text">定义消息对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F"><span class="toc-number">8.2.</span> <span class="toc-text">判断是否登录成功</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF"><span class="toc-number">8.3.</span> <span class="toc-text">服务端收发消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="toc-number">8.4.</span> <span class="toc-text">客户端接收消息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pipline-%E5%92%8C-ChannelHandler"><span class="toc-number">9.</span> <span class="toc-text">Pipline 和 ChannelHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipline-%E5%92%8C-ChannelHandler-%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-number">9.1.</span> <span class="toc-text">Pipline 和 ChannelHandler 的构成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ChannelHandler-%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">9.2.</span> <span class="toc-text">ChannelHandler 的分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84-Pipeline"><span class="toc-number">10.</span> <span class="toc-text">构建服务端和客户端的 Pipeline</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%86%E5%8C%85-%E7%B2%98%E5%8C%85"><span class="toc-number">11.</span> <span class="toc-text">拆包&#x2F;粘包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty-%E8%87%AA%E5%B8%A6%E7%9A%84%E6%8B%86%E5%8C%85%E5%99%A8"><span class="toc-number">11.1.</span> <span class="toc-text">Netty 自带的拆包器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LengthFieldBasedFrameDecode-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">11.2.</span> <span class="toc-text">LengthFieldBasedFrameDecode 的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%92%E7%BB%9D%E9%9D%9E%E6%9C%AC%E5%8D%8F%E8%AE%AE%E8%BF%9E%E6%8E%A5"><span class="toc-number">11.3.</span> <span class="toc-text">拒绝非本协议连接</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ChannelHandler-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">12.</span> <span class="toc-text">ChannelHandler 生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-ChannelHandler-%E7%9A%84%E7%83%AD%E6%8F%92%E6%8B%94%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BA%AB%E4%BB%BD%E6%A0%A1%E9%AA%8C"><span class="toc-number">13.</span> <span class="toc-text">使用 ChannelHandler 的热插拔实现客户端身份校验</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BA%92%E8%81%8A"><span class="toc-number">14.</span> <span class="toc-text">客户端互聊</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80%E5%8D%95%E8%81%8A%E5%8E%9F%E7%90%86"><span class="toc-number">14.1.</span> <span class="toc-text">一对一单聊原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81%E4%B8%8E-Channel-%E7%BB%91%E5%AE%9A"><span class="toc-number">14.2.</span> <span class="toc-text">用户状态与 Channel 绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF%E5%B9%B6%E8%BD%AC%E5%8F%91"><span class="toc-number">14.3.</span> <span class="toc-text">服务端接收消息并转发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF-1"><span class="toc-number">14.4.</span> <span class="toc-text">客户端接收消息</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/02/01/asm%E6%A1%86%E6%9E%B6/" title="asm框架"><img src="/img/105802820_p0_square1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="asm框架"/></a><div class="content"><a class="title" href="/2025/02/01/asm%E6%A1%86%E6%9E%B6/" title="asm框架">asm框架</a><time datetime="2025-02-01T11:17:02.000Z" title="发表于 2025-02-01 19:17:02">2025-02-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/23/zookeeper/" title="zookeeper"><img src="/img/51160511_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="zookeeper"/></a><div class="content"><a class="title" href="/2025/01/23/zookeeper/" title="zookeeper">zookeeper</a><time datetime="2025-01-23T04:36:35.000Z" title="发表于 2025-01-23 12:36:35">2025-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/02/netty-%E5%AE%9E%E6%88%98/" title="netty 入门实战"><img src="/img/51160511_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="netty 入门实战"/></a><div class="content"><a class="title" href="/2025/01/02/netty-%E5%AE%9E%E6%88%98/" title="netty 入门实战">netty 入门实战</a><time datetime="2025-01-02T05:57:25.000Z" title="发表于 2025-01-02 13:57:25">2025-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/08/%E6%89%8B%E6%92%B8RPC/" title="手撸RPC框架"><img src="/img/XYJ1169080555732136.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="手撸RPC框架"/></a><div class="content"><a class="title" href="/2024/08/08/%E6%89%8B%E6%92%B8RPC/" title="手撸RPC框架">手撸RPC框架</a><time datetime="2024-08-08T01:05:01.000Z" title="发表于 2024-08-08 09:05:01">2024-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://cdn.acwing.com/media/article/image/2024/07/15/104918_5a7a826942-9bb38b44a28c5e6395ac14abdc976d9e.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2024/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2024-07-30T06:00:14.000Z" title="发表于 2024-07-30 14:00:14">2024-07-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By XYJ</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>